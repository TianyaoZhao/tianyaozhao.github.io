# 计算机组成原理

## 计算机系统概述

### 计算机系统层次结构

==计算机系统的基本组成==

==计算机硬件的基本组成==

==计算机硬件和软件的关系==

==计算机系统的工作原理：存储程序方式、高级语言程序和机器语言程序的转换、程序和指令的执行过程==

1. **计算机硬件**

    1. 冯诺依曼计算机

        采用**存储程序**的工作方式，计算机硬件系统有**运算器、存储器、控制器、输入设备、输出设备**五部分组成

        **指令和数据**以同等地位存储在存储器中，均用二进制代码表示

        指令由**操作码和地址码**组成，操作码给出**操作**的类型，地址码给出**操作数**的地址

        **存储程序**的基本思想是将实现编制好的程序和原始数据送入主存储器后才能执行，一旦启动，无须人为干预，逐条执行

    2. 计算器的功能部件

        ![image-20240325172903846](./.assets/image-20240325172903846.png)

        1. 输入设备输出设备

        2. 存储器（内存+外存）

            **CPU可以直接访问内存，外存中的信息必须调入内存后才能供CPU访问**

            ![image-20240325171914387](./.assets/image-20240325171914387.png)

            存储器地址寄存器（MAR）存放访存地址：MAR用于寻址，**位数表示最多的寻址的存储单元数**，10位就是1024个存储单元

            存储器数据寄存器（MDR）存放从存储器读或写的信息：**位数等于存储字长**

            **MAR和MDR都在CPU中**

        3. 运算器

            算术运算逻辑单元（ALU）+ 程序状态寄存器（PSW），ALU包含若干通用寄存器

        4. 控制器

            计数器（PC）+指令寄存器（IR）+控制单元（CU）组成

            PC存放当前执行的指令的地址，自动加1的功能，**与MAR有通路**

            IR存放当前执行的指令，**内容来自MDR**

            指令中操作码OP（IR）送往CU，而地址码AD（IR）送往MAR，用于取操作数

            

2. **计算机系统的工作原理**

    1. 存储程序工作方式

        ![](./.assets/image-20240325173133575.png)

        一个程序的执行就是周而复始的执行一条条指令的结果：从主存储器中取指令、对指令进行译码、计算下一条指令的地址、取操作数并执行、将结果送回存储器

    2. 从源程序到可执行文件

        ![image-20240325173414096](./.assets/image-20240325173414096.png)

        1. 预处理阶段：预处理器对以字符#开头的命令进行处理
        2. 编译阶段：对预处理后的源程序进行编译，生成一个汇编语言程序
        3. 汇编阶段：对汇编语言翻译成机器语言
        4. 链接阶段：将可重定位目标程序和标准库函数合并，生成可执行文件

    3. **指令执行过程描述**

        1. 取指令

            PC - MAR-M-MDR-IR

            **根据PC取指令到IR**。将PC的内容送到MAR，MAR中的内容直接送到地址线，同时将控制器打开读信号，主存储器根据地址线的地址和读信号，读出指令，经过数据总线送到MDR，在由MDR送达IR

        2. 分析指令 

            OP（IR）- CU

            **指令译码并送出控制信号**。控制器根据IR指令中的操作码，生成相应的控制信号，送到不同的执行部件

        3. 执行指令

            AD（IR）- MAR - M - MDR - ACC

            **取数操作**。将IR指令中的地址码送到MAR，MAR中的内容送到地址线，同时控制器打开信号，主存储器根据地址线的地址和读信号，读出操作数，经过数据总线送到MDR，在由MDR送达ACC

        4. 每取完一条指令，还要为下一条指令准备**（PC）**+1 - > PC，带括号表示PC中的内容

### 计算机性能指标

==吞吐量、响应时间、CPU时钟周期、主频、CPI、CPU执行时间==

==MIPS、MLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS==

1. **机器字长**

    32位 64位：计算机一次整数运算所能处理的二进制数据的位数，一般等于**通用寄存器的位数和ALU的宽度**

2. **数据通路带宽**

    数据总线一次所能传送信息的位数。指外部数据总线的宽度

3. **主存容量**

    主存储器所能存储信息的最大容量，以字节来衡量

    **MAR的位数**：反映存储单元的个数

    **MDR的位数**：反映存储单元的字长

    例如：MAR=16位，表示有$2^{16}=65536$个存储单元 64k；MDR有32位，表示机器字长位32

    总存储容量为$64k×32$

4. **运算速度**

    吞吐量（单位时间内处理请求的数量）和响应时间（用户发出请求到得到结果所需要的时间）；

    主频（CPU的时钟频率）和CPU时钟周期（CPU工作的最小时间单位）

    **CPI：执行一条指令所需要的CPU时钟周期数**，平均值

    **IPS：每秒执行多少条指令**

    ​	主频为1s有的时钟周期数，CPI为一条指令需要的平均周期数，相除就是1s执行的指令数
    $$
    IPS = \frac{主频}{CPI}
    $$
    **CPU的执行时间：执行一个程序花费的时间**
    $$
    CPU的执行时间=\frac{指令条数×CPI}{主频} = 指令条数×CPI×CPU时钟周期
    $$
    **MIPS：每秒执行多少百万条指令**
    $$
    MIPS=\frac{指令条数}{执行时间×10^6}=\frac{主频}{CPI×10^6}
    $$
    **FLOPS：每秒执行多少次浮点数运算**

## 数据的表示和运算

### 数制与编码

==进位计数制及其相互转换，定点数的编码表示==

1. **进位计数法**

    一个r进制数$K_nK_{n-1}...K_0K_{-1}...K_{-m}$的数值可以表示为
    $$
    K_{n}r^{n}+K_{n-1}r^{n-1}+\cdots+K_{0}r^{0}+K_{-1}r^{-1}+\cdots+K_{-m}r^{-m}=\sum_{i=n}^{-m}K_{i}r^{i}
    $$
    r是基数，$r^i$是位权，K是0~r-1的任意一个数

2. **不同进制数之间的相互转换**

    1. 二进制数转为八进制数和十六进制数

        从小数点开始，向高位和低位依次数3或4，不足补零

        ![image-20240328103534594](./.assets/image-20240328103534594.png)

        ![image-20240328103552087](./.assets/image-20240328103552087.png)

    2. 八进制数或十六进制数转为二进制数

        每一位八进制数转为3位二进制数

        每一位十六进制数转为4位二进制数

    3. 任意进制数转为十进制数

        **按位权展开**

    4. 十进制数转为任意进制数

        **整数部分：除基倒取余，商0结束**

        **小数部分：乘基顺取整，乘积为1.0结束**

        123.6875

        ![image-20240328104008221](./.assets/image-20240328104008221.png)

        ![image-20240328104115304](./.assets/image-20240328104115304.png)

        

        

        

3. **定点数的编码表示**

    1. 真值和机器数

        真值：带+或-的数

        机器数：0表示+，1表示-，**把符号数字化**

    2. 机器数的定点表示

        **通常用补码整数表示整数、原码小数表示浮点数的尾数部分、移码表示浮点数的阶数部分**

        定点小数：（约定小数点在符号位之后）（符号位$x_0$，数值部分为尾数）

        ![image-20240328105009547](./.assets/image-20240328105009547.png)

        定点整数：（约定小数点在数值位最后）（符号位$x_0$，数值部分为尾数）

        ![image-20240328105210182](./.assets/image-20240328105210182.png)

        

4. **原码、反码、补码、移码**

    1. 原码表示法

        **机器数的最高位表示数符，其余各位表示数的绝对值**

        例如(字长8位)：$x_1=+1100,[x_1]_{原}=0,0001110$，$x_2=-1110,[x_2]_原=1,0001110$

        **若字长为n+1,则原码整数的表示范围为   $-(2^n-1) ≤ x ≤ 2^n-1$**，关于原点对称

        **0的原码表示有正零和负零两种形式 $[+0]_原=0,0000000 \ \ [-0]_原=1,0000000$**

    2. 补码表示法

        **补码表示的加减运算统一采用加法实现**

        **正数的补码和原码相同**

        **负数的补码，除符号位，从右往左数，找到第一个数字1，1及右边的数字都不变，左边的都取反**

        例如(字长8位)：$x_1=+1100,[x_1]_{原}=0,0001110，[x_1]_补=0，0001110$，$x_2=-1110,[x_2]_原=1,0001110，[x_2]_补=1，1110010$

    3. 反码表示法

        **正数的反码和原码相同**

        **负数的反码，除符号位都取反**

    4. 移码表示法

        **常用来表示浮点数的阶码，它只能表示正数**

        **移码就是在真值X上加上一个常数，通常取$2^n$**

        **移码，补码符号位取反，其余相同**

        例如(字长8位)：$x_1=+1100,[x_1]_{原}=0,0001110，[x_1]_移=2^7+1100=1,0001100$

        $x_2=-10101,[x_2]_{原}=1,0010101，[x_2]_移=2^7+(-10101)=1，1101011$





### 运算方法和运算电路

==基本运算部件：加法器、ALU==

==加减法运算：补码加/减运算，标志位的生成==

==乘除法运算：乘除法运算的原理，乘除法运算的逻辑电路==

1. **基本运算部件**

    1. 带标志加法器

        ![image-20240328152032271](./.assets/image-20240328152032271.png)

        溢出标志：$OF=C_n \oplus C_{n-1}$    

        ​	就是看数值位和符号位的进位情况，**都有进位都没进位就是没有溢出，其中一个有进位就是溢出了**

        符号标志：$SF=F_{n-1}$

        ​	就是符号位的输出情况

        零标志：$ZF=1$

        ​	只有在结果的每一位都是0的情况下，相或才能得到全0输出，ZF=1

        ​	只要有一位是1，相或为1，ZF=0

        进位/借位标志：$CF=C_{out}\oplus C_{in}$

        ​	不好理解，[详见](https://blog.csdn.net/weixin_41515197/article/details/104399064)

    2. ALU

        ![image-20240328154335246](./.assets/image-20240328154335246.png)

        加减乘除 与或非运算都能进行

    

2. **定点数的加减运算**



### 整数的表示和运算

==无符号整数的表示和运算==

==有符号整数的表示和运算==

### 浮点数的表示和运算

==浮点数的表示==

==浮点数的加减运算、IEEE754浮点数表示==

## 存储系统

### 存储器概述

![image-20240613165648960](./.assets/image-20240613165648960.png)

==存储器的分类、层次化存储器的结构==

1. **分类**

    1. 按照作用分：主存（内存）、辅存（外存）、高速缓存（Cache）
    2. 按照存取方式分：随机存储（RAM）、顺序存取（SAM）
    3. 按照信息可更改：读写存储（磁盘、内存、cache）、只读存储（ROM）比如bios

    **主存-辅存**：实现了虚拟存储系统，解决了主存容量不够的问题

    **Cache-主存**：解决了主存与CPU速度不匹配的问题

2. **存储器的性能指标**

    存储容量、单位成本、存储速度

    1. **存储容量=存储字数×字长（1M×8位）**

    2. 单位成本=每位价格=总成本/总容量

    3. 存储速度（每秒传送信息的位数）（数据传输速率）= **数据的宽度（存储字长 ）/存取周期**

        1. 存取时间$T_a$指启动一次存储操作，到操作完成所经历的时间，分为读出时间和写入时间

            ![image-20240616142607140](./.assets/image-20240616142607140.png)

        2. 存取周期$T_m$指进行依次完整读/写操作的时间

        3. 主存带宽$B_m$，（数据传输速率）=**每秒从主存进出信息的最大数量** 字/s bit/s 字节/s

3. 多层次的存储器

    ![image-20240328160031125](./.assets/image-20240328160031125.png)

    

### 主存储器



==RAM、SRAM、DRAM、Flash闪存==

![image-20240616144730825](./.assets/image-20240616144730825.png)

1. **主存储器的基本组成**

    ![image-20240616143433590](./.assets/image-20240616143433590.png)

    读取过程

    ![image-20240616143709823](./.assets/image-20240616143709823.png)

    **片选线控制当前片是否可用** 

    ![image-20240616143918326](./.assets/image-20240616143918326.png)

    **寻址**

    总容量为**1KB**，字长为4B

    1. 按字节寻址：1K个单元。每个单元1B
    2. 按字寻址：256个单元，每个单元4B
    3. 按半字寻址：512个单元，每个单元2B
    4. 按双字寻址：128个单元，每个单元8B

2. **SRAM和DRAM**

    RAM随机访问存储器，不会因为存放的物理位置不同而影响读取速度

    DRAM动态RAM：用于主存（栅极电容）、SRAM静态RAM：用于Cache（双稳态触发器 ）

    ![image-20240616145601837](./.assets/image-20240616145601837.png)

    DRAM的刷新：读出一行的信息，重新写入，占一个读写周期

      ![image-20240616145944826](./.assets/image-20240616145944826.png)

3. **只读存储器ROM**

    比较

    1. RAM--易失，断电数据消失

    2. ROM--不易失，断电后数据不消失

    3. MROM（掩膜）、PROM(编程)、EPROM（可擦除、可编程）、Flash闪存(U盘SD卡)、SSD（控制单元+flash闪存）

4. **多模块存储器**

    每个模块都有**相同的容量和存取速度**，各个模块都有独立的读写控制电路、地址寄存器、数据寄存器，既可以并行工作，也可以交叉工作

    ![image-20240616151447368](./.assets/image-20240616151447368.png)

### 主存储器与CPU的连接

![image-20240616151659649](./.assets/image-20240616151659649.png)

**单块存储芯片和CPU的连接**

![image-20240616151806870](./.assets/image-20240616151806870.png)

**位扩展**，可以理解为增加一次读取数据的位数，地址总线都是相同的

**8个8K×1位 -> 1个8K×8位**

![image-20240616152244542](./.assets/image-20240616152244542.png)

**字扩展，**可以理解为利用空闲的地址总线，**用译码器的输出作为片选信号**，来进行片选

![image-20240616153244038](./.assets/image-20240616153244038.png)

**字位同时扩展**

![image-20240616153353676](./.assets/image-20240616153353676.png)

### 外部存储器

![image-20240616160813085](./.assets/image-20240616160813085.png)

==磁盘存储器、固态硬盘SSD==

1. 磁盘存储器

    1. 存储区域

        ![image-20240616154201822](./.assets/image-20240616154201822.png)

        **磁头数：**即记录面数，表示硬盘总共有多少个磁头，一个记录面对应一个磁头（有时候正面反面都有磁头）

        **柱面数：**表示一个记录面上有多条磁道。相同位置的磁道，组成一个柱面

        **扇区数：**表示一条磁道有多少个扇区

    2. 硬盘存储区

        磁盘驱动器+磁盘控制器

    3. 性能指标

        **磁盘容量**：一个磁盘所能存储的字节总数

        **记录密度**：盘片上，单位面积记录的二进制信息量（道密度、位密度、面密度）

        ![image-20240616160053088](./.assets/image-20240616160053088.png)

        ​	**道密度：**单位长度上的磁道数，60道/cm

        ​	**位密度：**一条磁道上，单位长度记录的二进制位数。（==所有磁道记录的信息量是相同的，并不是圆越大记录信息越多，而是每个磁道的位密度不同==）

        ​	**面密度：**道密度*位密度

        **平均存取时间**：

        ![image-20240616160315147](./.assets/image-20240616160315147.png)

        ​	= **寻道时间**（磁头移动至目的磁道）+

        ​	   **旋转延迟时间**（磁头定位到指定扇区）+  一般等于转动半圈的时间

        ​	   **传输时间**（传输数据花费的时间）

        **数据传输率**：磁盘在单位时间向主机传送的字节数

        ​		假设磁盘转数r 转/s，每条磁道容量为N个字节，则数据传输率为$D_r=rN$

    4. 磁盘地址

        ![image-20240616160628499](./.assets/image-20240616160628499.png)

    5. 硬盘工作过程

        寻址+读盘+写盘

2. 固态硬盘SSD

    ![image-20240616160844146](./.assets/image-20240616160844146.png)

    ![image-20240616161025933](./.assets/image-20240616161025933.png) 

### 高速缓冲存储器

==Cache的基本原理、Cache与主存之间的映射关系==

==Cache中主存块的替换方法、Cache的写策略==

![image-20240617113631927](./.assets/image-20240617113631927.png)

1. **Cache的基本原理**

    把内存里的内容调入更高速的cache中，cache用SRAM实现，速度快成本高，**把CPU目前访问的周围的部分数据放入Cache中**

    **空间局部性：** 在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是相邻的（数组元素，顺序执行的指令代码）

    **时间局部性：** 在最近的未来要用到的信息，很可能是现在正在使用的信息（循环结构内的变量）

      ![image-20240617110611342](./.assets/image-20240617110611342.png)

    **性能分析：**

    先访问Cache，Cache没有命中再访问内存；

    访问Cache和访问内存同时开始，如果命中Cache，停止访问内存

    ![image-20240617113206395](./.assets/image-20240617113206395.png)

    **如何界定周围**：把主存的存储空间**分块**，主存和Cache之间以块为单位进行数据交换，每次被访问的主存块，一定会被立即调入Cache

    ![image-20240617113519125](./.assets/image-20240617113519125.png)

2. **Cache和主存的映射方式**

    ![image-20240617114923835](./.assets/image-20240617114923835.png)

    ![image-20240617113803359](./.assets/image-20240617113803359.png)

    1. 全相联映射：任意放

        ![image-20240617114235062](./.assets/image-20240617114235062.png)

    2. 直接映射：放在特定位置，主存块号%Cache块数

        ![image-20240617114553104](./.assets/image-20240617114553104.png)

    3. 组相联映射：分组，组间：主存块号%分组数，组内： 全相联

        ![image-20240617114908251](./.assets/image-20240617114908251.png)

3. **Cache的替换算法**

    ![image-20240617120531115](./.assets/image-20240617120531115.png)

    Cache很小，主存很大，Cache满了咋办？

    1. 全相联：Cache满了才选择替换
    2. 直接映射：对应位置非空直接替换
    3. 组相联：组内满了，选择替换

    因此替换算法只会用在1、3中

    1. **随机算法**：随机选择一块替换

        ![image-20240617115238005](./.assets/image-20240617115238005.png)

    2. **先进先出**：先进去的先被替换

        ![image-20240617115334590](./.assets/image-20240617115334590.png)

    3. **近期最少使用LRU**：为每一个Cache块设置一个计数器用于**记录每个Cache多久没有被访问过了，替换最大的**；做题时，从当前主存块号往前找，哪个靠前替换哪个

        ![image-20240617120028400](./.assets/image-20240617120028400.png)

        ![image-20240617120241859](./.assets/image-20240617120241859.png)

    4. **最不经常使用算法:**计数器**记录每个Cache块被访问过多少次，替换最小的**

        ![image-20240617120432709](./.assets/image-20240617120432709.png)

        有些块会长期存在Cache中，导致很长一段时间不会被替换掉

4. **Cache的写策略**

    ![image-20240617122309828](./.assets/image-20240617122309828.png)

    CPU修改了Cache中的数据，如何保持对应的主存和Cache的内容一致

    ==写命中==

    1. **写回法：**当CPU对Cache写命中时，**只修改Cache内容，而不立即写入主存**，只有当**此块被换出时才写回主存**，未被修改的不必写回

        ![image-20240617121533885](./.assets/image-20240617121533885.png)

    2. **全写法：**当CPU对Cache写命中时，必须**把数据同时写入Cache和主存**，一般使用写缓冲，缺点是访存次数增加，速度变慢但是能保证数据的一致性

        ![image-20240617121921090](./.assets/image-20240617121921090.png)

    ==写不命中==

    1. **写分配法：**当CPU对Cache写不命中时，把主存中的块调入Cache没在Cache中修改，**搭配写回法**

        ![image-20240617122124904](./.assets/image-20240617122124904.png)

    2. 非写分配法：当CPU对Cache写不命中时，**只写入主存不调入Cache** ，**搭配全写法**



### 虚拟存储器

==虚拟存储器的基本概念==

==页式虚拟存储器：基本原理、页表、地址转换、TLB(快表）==

==段式虚拟存储器的基本原理==

==段页式虚拟存储器的基本原理==

**虚拟存储器的基本概念**
虚拟存储器是指具有请求调入和置换功能，能从逻辑上对内存容量加以扩存的一种存储器系统

1. 页式虚拟存储器
页式管理:是把虚拟存储空间和实际空间等分成固定大小的页,各虚拟页可装入主存中的不同实际页面位置.页式存储中,处理机逻辑地址由虚页号和页内地址两部分组成,实际地址也分为页号和页内地址两部分,由地址映射机构将虚页号转换成主存的实际页号.页式管理用一个页表,包括页号,每页在主存中起始位置,装入位等.页表是虚拟页号与物理页号的映射表.页式管理由操作系统进行,对应用程序员透明的.
2. 段式虚拟存储器
段式管理: 把主存按段分配的存储管理方式.它是一种模块化的存储管理方式,每个用户程序模块可分到一个段,该程序模块只能访问分配给该模块的段所对应的主存空间.段长可以任意设定,并可放大和缩小.系统中通过一个段表指明各段在主存中的位置.段表中包括段名(段号),段起点,装入位和段长等.段表本身也是一个段.段一般是按程序模块分的.
3. 段页式虚拟存储器
段页式管理:是上述两种方法的结合,它将存储空间按逻辑模块分成段,每段又分成若干个页,访存通过一个段表和若干个页表进行.段的长度必须是页长的整数倍,段的起点必须是某一页的起点.
4. TLB(快表)
在虚拟存储器中进行地址变换时,需要虚页号变换成主存中实页号的内部地址变换这一过程缓存时首先要到主存查页表，然后才能根据主存物理地址访问主存的存取指令或数据。因此采用虚拟存储器机制后，访存的次数增加了。为了减少访存的次数，往往将页表中最活跃的几个页表项复制到高速缓存中。这种在高速缓存中的页表项称为快表（translation look aside buffer）查表时,根据虚页表同时查找快表和慢表,当在快表中查到该虚页号时,就能很快找到对应的实页号,将其送入主存实地址寄存器,同时使慢表的查找作废,这时主存的访问速度没降低多少.如果在快表中查不到,则经过一个访主存的时间延迟后,将从慢表中查到的实页送入实地址寄存器,同时将此虚页号和对应的实页号送入快表。

## 指令系统

### 指令系统

1. **指令的基本格式**

    ![image-20240617124606012](./.assets/image-20240617124606012.png)

    操作码（OP）+地址码（A）

    1. 零地址指令：不需要操作数，空操作、停机、关中断
    2. 一地址指令：取反，求补，需要两个操作数，但是其中一个操作数隐含在某个寄存器（acc累加寄存器中）
    3. 二地址指令：加减，逻辑与或
    4. 三地址指令：（A1）op （A2）-> (A3)
    5. 四地址指令：（A1）op （A2）-> (A3) A4：下一条要执行的指令的地址

    ==指令字长==：一条指令的总长度，半字长（64/32**机器字长的一半**）、单字长、双字长

2. **扩展操作码指令格式**

    ==定长指令字结构+可变长的操作码=扩展操作码指令==

    1. 不允许**短的编码是长的编码的前缀**
    2. 各个指令的操作码一定不能重复

    ![image-20240617124821271](./.assets/image-20240617124821271.png)

### 指令的寻址方式

==如何确定下一条指令的地址？==PC指明下一条指令的存放地址 （PC）+ 1 —> PC

1. 指令寻址

    ![image-20240617125755538](./.assets/image-20240617125755538.png)

    顺序寻址  (PC)+"1" ->PC,  **关键在于按字编址还是按字节编址**

    跳跃寻址  **由转移指令指出** ，JMP无条件跳转

2. 数据寻址

    ![image-20240617130401936](./.assets/image-20240617130401936.png)

    ==确定本条指令的地址码指明的真实地址==，对JMP的指令后面的数的解读方式不一样

    ![image-20240617130454471](./.assets/image-20240617130454471.png)

    1. 直接寻址 EA=A
    2. 间接寻址 EA=（A）  **真实地址是地址为A的主存单元里的数**，可存放的地址范围更大了
    3. 寄存器寻址 EA=$R_i$
    4. 寄存器间接寻址 EA=$(R_i)$
    5. 隐含寻址：不是明显的给出操作数地址，而是在指令中隐含着操作数的地址
    6. 立即寻址：形式地址A就是操作数本身，而不是地址。**又称为立即数**
    7. 偏移寻址：形式地址视为某个地址作为起点的**偏移量**
        1. 基址寻址：EA=（BR）+A   基址寄存器  面向底层，a是偏移量，br是基地址
        2. 变址寻址：EA=（IX）+A     变址寄存器  面向用户，ix偏移量，a是基地址
        3. 相对寻址：EA=（PC）+ A  程序计数器
    8. 堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（SP寄存器）作为操作数地址

### 程序的机器级代码表示

### CISC和RISC的基本概念

cisc复杂指令系统（x86架构），risc精简指令集（arm架构）

![image-20240617131957468](./.assets/image-20240617131957468.png)

## 中央处理器

### CPU的功能和基本结构

![image-20240617132323629](./.assets/image-20240617132323629.png)

![image-20240617132506069](./.assets/image-20240617132506069.png)

1. **运算器的基本结构**

     算数逻辑单元ALU、通用寄存器组、暂存寄存器、程序状态字寄存器PSW、移位器、计数器

    ![image-20240620143308723](./.assets/image-20240620143308723.png)

2. **控制器的基本结构**

    取指令、分析指令、执行指令

      ![image-20240620143726497](./.assets/image-20240620143726497.png)

### 指令执行过程

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间，每个指令内的机器周期数不同，每个机器周期内的节拍数也可以不相同

### 数据通路的功能和基本结构

### 控制器的功能和基本原理

### 异常和中断机制

### 指令流水线

### 多处理器的基本概念

## 总线

### 总线概述

### 总线事务和定时

## 输入/输出系统

### I/O系统的基本概念

### I/O接口

### I/O方式
