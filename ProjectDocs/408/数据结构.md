# 数据结构

## 绪论

```mermaid
graph LR
    绪论-->数据结构
    绪论-->五个特征
    
    数据结构-->逻辑结构
    数据结构-->物理结构
    数据结构-->数据运算
    
    五个特征-->算法定义
    五个特征-->五个特性
    五个特征-->效率的度量
    
    逻辑结构-->block2
    逻辑结构-->block3
    
   	block1["有穷性、确定性、可行性、输入、输出"]
    五个特性-->block1
    效率的度量-->时间复杂度
    效率的度量-->空间复杂度
    
    block2["线性结构：线性表、栈、队列"]
    block3["非线性结构：树、图、集合"]
    
  
```



### 数据结构的基本概念

#### 数据结构的三要素

![image-20240525152501095](./.assets/image-20240219115355585.png)

1. 逻辑结构
    1. 线性结构：线性表（1对1）
    2. 非线性结构：集合（同属于一个集合）、树（1对多）、图（多对多）
2. 存储结构（物理结构）
    1. 顺序存储：**逻辑上相邻**的元素存储在物**理位置上也相邻**的存储单元中；优：随机存取、每个元素占空间少 缺：只能使用相邻的整块存储单元，产生较多外部碎片
    2. 链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助**指针**来表示元素之间的逻辑关系；优：不会出现外部碎片 缺：指针占用额外的存储空间，只能实现顺序存取
    3. 索引存储：存储信息元素同时建立附加的**索引表**，索引表中的每项为**索引项（关键字+地址）**优：检索快 缺：索引表占用额外空间，增删数据需要修改索引表
    4. 散列存储（哈希存储）：根据元素的**关键字**直接**计算存储地址** 优：检索、增加、删除节点速度快 缺：散列函数不好，会产生冲突
3. 数据的运算



### 算法和算法评价

#### 算法效率的度量

##### 时间复杂度

一个语句的**频度**是指该语句在算法中被重复执行的次数。所有语句的频度之和为$T(n)$，他是该算法问题规模$n$的函数，时间复杂度主要分析$T(n)$的数量级。**算法中最深层循环内的语句的频度与$T(n)$ 同数量级，因此通常采用最深层循环内的语句的频度$f(n)$来分析算法的时间复杂度**。因此时间复杂度为$T(n) = O(f(n))$

上式中$O$的含义是$T(n)$的数量级，表示同阶，同等数量级
$$
T(n) = O(f(n)) \iff \lim_{n \to \infty} \frac{T(n)}{f(n)} = k
$$

**数量级比较：**
$$
O(1) \lt O(\log_2{n}) \lt O(n) \lt O(n\log_2{n}) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!) \lt O(n^n)
$$

**主定理求时间复杂度**

形如：
$$
T(n) = aT(\frac{n}{b}) + f(n)\\
$$
$n^{\log_{a}{b}}$与$f(n)$比较

1. $n^{\log_{a}{b}} \lt f(n)$: $O(f(n))$
2. $n^{\log_{a}{b}} \gt f(n)$: $O(n^{\log_{a}{b}})$
3. $ n^{\log_{a}{b}} = f(n)$: $O(n^{\log_{a}{b}}\log_2{n})$




##### 空间复杂度

算法的空间复杂度$S(n)$定义为该算法所需要的存储空间，它是问题规模为$n$的函数，记为：
$$
S(n) = O(g(n))
$$
只需要关注**存储空间的大小和与问题规模相关的变量**





### Q&A

1. 用循环比递归的效率高吗？

    循环和递归两者是可以互换的，不能决定性的说循环的效率比递归高

    递归的优点是：代码清晰，容易检查正确性；缺点是：当递归调用的次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况

    循环的优点是：结构简单，速度快；缺点是：它不能解决全部的问题，有的问题适合用递归来解决，不适合用循环

2. 贪心法，动态规划法以及分治法的区别？

    **贪心算法**顾名思义就是做出当前来看是最好的结果，它不从整体上加以考虑，也就是**局部最优解**。贪心从上往下，从顶部一步一步最优，得到最后的结果，它不能保证全局最优解，与贪心选择的策略有关

    **动态规划法**把问题分解成子问题，这些子问题可能有重复，可以**记录**下前面的子问题的结果防止重复计算，前一个子问题对后一个子问题产生一定的影响。

    **分治法**将原问题划分为n个小规模的子问题，**递归的**解决这些子问题，然后再**合并**子问题的解，就是原问题的解

## 线性表

```mermaid
graph LR
	线性表-->顺序存储
	线性表-->链式存储
	
	顺序存储-->顺序表
	链式存储-->单链表
	链式存储-->双链表
	链式存储-->循环链表
	block["静态链表（借助数组实现）"]
	链式存储-->block
```



### 线性表的基本定义和基本操作

#### 线性表的定义

线性表是具有**相同数据类型**的n个数据的**有限序列**，除第一个元素和最后一个元素，每个元素都有一个**直接前驱**和**直接后继**

#### 线性表的基本操作

1. `InitList(&L)`：初始化
2. `Length(L)`：表长
3. `LoacteElem(L, e)`：按值查找，返回位置
4. `GetElem(L, i)`：按位置查找，返回值
5. `ListInsert(&L, i, e)`：插入元素
6. `ListDelete(&L, i, &e)`：删除元素
7. `PrintList(L)`：打印表
8. `Empty(L)`：判空
9. `DestoryList(&L)`：销毁表

### 顺序表和链表的比较

1. 存取方式

    顺序表可以顺序存取也可以随机存取，链表只能从表头顺序存取元素。例如在第i个位置上执行存/取操作，顺序表仅需一次访问，而链表需要从头访问

2. 物理结构

    都是线性结构，顺序表：逻辑上相邻的元素，存储的物理位置也相邻；链表：逻辑上相邻的元素，存储物理位置不一定相邻

3. 查找、插入、删除操作

    对于按值查找，顺序表无序时，两者时间复杂度都是$O(n)$；顺序表有序时，二分查找，时间复杂度为$O(logn)$

    对于按序号查找，顺序表时间复杂度为$O(1)$，链表的时间复杂度为$O(n)$

    对于插入删除操作，顺序表需要**平均移动半个表长**，链表只需要修改指针即可

4. 空间分配

    顺序表在静态存储空间分配下一旦装满就不能扩充；预先分配过大造成浪费，过小造成溢出。

    链表只需要在需要时申请分配，只要内存有空间就可以分配

### Q&A

1. 头指针和头节点的区别？

    **头指针：**指向第一个节点存储位置的指针，具有标识作用，无论链表为空，头指针必须存在

    **头节点：**是放在第一个元素的节点之前，**便于在第一个元素之前进行插入和删除操作**，头节点不是链表的必须元素可有可无，数据域也不存放任何信息

2. 

## 栈、队列、数组

```mermaid
graph LR
	线性表--操作受限-->栈
	栈-->顺序栈
	栈-->链栈
	栈-->共享栈
	线性表--操作受限-->队列
	队列-->顺序队列
	队列-->链式队列
	队列-->双端队列
	队列-->循环队列

	线性表--推广-->数组
```

### 栈

#### 栈的基本概念

栈（stack）只允许**在一端进行插入和删除的线性表**

#### 顺序栈、链栈、共享栈

顺序栈：后进先出

链栈：

![image-20240525152501095](./.assets/image-20240525152501095.png)

共享栈：利用**栈底相对位置不变的特性**，可以让两个顺序栈共享一个一维数组空间，将两个共享栈的栈底设置为两端，栈顶指针向中间靠拢

![image-20240525152716869](./.assets/image-20240525152716869.png)

### 队列

#### 队列的基本概念

队列（queue）只允许在**一端插入**，在**另一端删除**

#### 顺序队列、链式对联、双端队列、循环队列

顺序队列：先进先出，**队头指针，队尾指针**，存在假溢出现象

![image-20240525153308624](./.assets/image-20240525153308624.png)

链式队列：

![image-20240525153404255](./.assets/image-20240525153404255.png)

循环队列：将队列臆造为一个环状空间，利用除法取余解决溢出问题

![image-20240525153341760](./.assets/image-20240525153341760.png)

双端队列：允许两端都可以插入和删除的线性表

![image-20240525153534815](./.assets/image-20240525153534815.png)



### 栈和队列的应用

#### 栈在括号匹配中的算法思想

1. 凡是出现左括号，则进栈
2. 凡是出现右括号
    1. 首先检查栈是否空？若空，则右括号多余
    2. 否则和栈顶元素进行比较，若相匹配，则栈顶左括号出栈
3. 表达式检验结束
    1. 若栈空，则匹配正确
    2. 否则说明左括号有多余

#### 栈在后缀表达式求值中的算法思想

中缀转后缀：

1. 按运算顺序加括号
2. 将运算符移动至对应右括号的前面
3. 除去所有的括号

计算机中缀转后缀：

1. 遇到操作数，直接加入后缀表达式
2. 遇到左括号，直接入栈，遇到右括号，依次弹出栈中的运算符，加入后缀表达式，直到弹出左括号。（**左括号删除，不加入后缀表达式**）
3. 遇到运算符，优先级高于栈顶或（，入栈，低于栈顶，一直出栈直至高于，然后把当前符号入栈![image-20240525161526352](./.assets/image-20240525161526352.png)

顺序扫描表达式的每一项，根据它的类型做出相应的操作：

1. 若是操作数。压栈
2. 若是操作符，从栈顶退出两个操作数**y x**， 形成运算指令 **x y**，将结果重新压栈
3. 表达式求完，栈顶的数就是结果

![image-20240525154401504](./.assets/image-20240525154401504.png)

#### 栈在递归中的应用

递归算法转换为非递归算法，通常需要借助栈来实现

#### 队列在层次遍历中的应用

二叉树的层次遍历：每次队头出队，扩展队头，直到队空

![image-20240525154756241](./.assets/image-20240525154756241.png)

#### 队列在计算机系统中的应用

1. 解决主机与外部设备之间速度不匹配的问题

    （以主机和打印机为例）主机输出数据给打印机打印，输出数据的速度比打印机快得多，若直接把输出数据送给打印机显然不行，解决的方法是设置一个**打印缓冲区**，主机把打印数据写入这个缓冲区，写满后就**暂停输出**，打印机从缓冲区按照**先进先出**的原则进行打印，打印完后**向主机发出请求**，主机再把数据写入缓冲区。保证的打印的数据准确由提高了主机的效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。

2. 解决由多用户引起的资源竞争问题

    （以CPU的资源竞争为例）在一个多终端的计算机上，多个用户需要CPU运行程序，通过各自的终端提出占用CPU的请求。操作系统**按照请求的时间先后顺序，把他们排成一个对立，每次把CPU分给队首用户使用**，当用户程序执行完毕或者是分配的CPU时间片用完，令其出队，再把CPU给新的队首使用。



### 数组和特殊矩阵

#### 数组的存储方式

**按行优先**存储和**按列优先**存储

#### 特殊矩阵

对称矩阵、三角矩阵、稀疏矩阵



### Q&A

1. 如何区分循环队列是空还满

    普通情况下，循环队列队空和队满的条件一样  `q.front == q.rear`

    ps:队头指针指向第一个数，队尾指针指向最后一个数的下一个位置，即**即将入队的位置**

    法1：牺牲一个存储单元来区分队空和队满 `( q.rear + 1 ) % Max_size == q.front` 

    法2：增设标识元素个数的数据成员 队空 `q.size == 0`  队满 `q.size == Max_size` 

2. 

## 串

```mermaid
graph LR
	block1["基本概念：主串、子串、串长"]
	串-->block1
 	串-->存储结构
 	block2["定长顺序存储
 			堆分配存储
 			块链存储"]
 	存储结构-->block2
 	串-->模式匹配算法
 	模式匹配算法-->暴力匹配
 	模式匹配算法--next数组-->KMP
 	模式匹配算法--nextval数组-->KMP算法的改进
```

### 串的模式匹配

求模式串在子串中的位置

## 树与二叉树

```mermaid
graph LR
	树-->二叉树
	树-->树和森林
	
	b1["概念：定义、存储结构"]
	b2["概念：定义、存储结构"]
	二叉树-->b1
	二叉树-->操作
	操作-->三种遍历
	操作-->线索二叉树
	二叉树-->应用
	应用-->排序二叉树
	排序二叉树-->平衡二叉树
	应用-->哈夫曼树
	树和森林-->b2
	b3["操作"]
	b4["应用"]
	树和森林-->b3
	树和森林-->b4
	b3-->遍历
	b3-->与二叉树的转换
	b4-->并查集
	
```

### 树和二叉树的基本概念

1. **树**：树是非线性结构，节点之间有明显的**层次关系**。根节点没有前驱，除根结点每个节点有且只有一个前驱；叶节点没有后继，除叶节点每个节点有多个后继

    递归定义：

    a.或者为空树

    b.或者由一个根节点和$m$个不相交的被称为根的有限集$T_1,T_2,...,T_m$子树组成。每个集合又是一棵树。

    ![image-20240604173446760](./.assets/image-20240604173446760.png)

    **祖先**（根到某个节点路径上的所有节点）、**子孙**（某个节点下面的所有节点）、**双亲**（父节点）、**孩子**（子节点）、**兄弟**（相同父节点的子节点）、**堂兄弟**（双亲在同一层的子节点）

    **节点的度**：孩子节点的个数； **树的度**：节点的最大度数

    **分支节点**：度大于0的节点；**叶子节点**：度为0的节点

    **节点层次**：节点所在的层的深度（根为1） **树高度**：节点的最大层数  **节点的高度**：以该节点为根的子树的高度

    **有序树**：各个子树不能交换 **路径**：两个节点路径序列 **路径长度**：两个节点路径的边数

2. **二叉树**：二叉树每个节点**最多有两颗子树**，并且二叉树的子树有左右之分，次序不能任意颠倒

    递归定义：

    a.或者为空二叉树

    b.或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别为二叉树。

3. **满二叉树**：除了叶子节点，每个节点均有两棵子树

    特点：高度为$h$，有$2^h-1$个节点，根节点编号为1，左孩子为$2i$，右孩子为$2i+1$，双亲为$\lfloor i/2 \rfloor$

    ![image-20240606141617561](./.assets/image-20240606141617561.png)

4. **完全二叉树**：除了最后一层外，其他任何一层的节点数均达到最大值，**且最后一层也只是在最右侧缺少节点**

    ![image-20240606141626019](./.assets/image-20240606141626019.png)

5. **二叉排序树**：左子树关键字小于根节点，右子树关键字大于根节点；左子树和右子树又分别是二叉排序树

6. **平衡二叉树**：树中任意一个节点的左子树和右子树高低之差的**绝对值不超过1**

7. **正则二叉树**：每个分支节点的出度为$m$，当$m=2$是满二叉树

8. **森林**：不相交的树的集合



### 树和二叉树的性质

1. 树的节点数等于所有节点的度数之和+1

    节点的度数等于节点的孩子数，最后在加上根节点

2. **非空二叉树上的叶子节点数=度为2的节点数+1，$n_0=n_2+1$**

    证明：$n=n_0+n_1+n_2$

    分支数 $B = n_1 + 2n_2$

    $n = B + 1$，得到  $n_0=n_2+1$

3. 非空二叉树的第$k$层最多有$2^{k-1}$个节点

4. 高度为$h$的二叉树最多有$2^h-1$个节点

5. 对于完全二叉树从上到下，从左到右编号$1,2,...,n$

    1. 若$i ≤ \lfloor n/ 2 \rfloor$，则节点$i$为分支节点，即最后一个分支节点的编号是$\lfloor n/2 \rfloor$
    2. 度为1的节点只可能是最后一个分支节点
    3. $i$的双亲节点为$\lfloor i /2 \rfloor$
    4. 节点$i$所在的层次（深度）为 $\lfloor log_i +1\rfloor$

6. 具有$n$个节点的完全二叉树的高度为$\lceil\log_2(n+1)\rceil$ 或  $\lfloor\log_2n\rfloor+1$

    证明：根据完全二叉树的定义
    $$
    2^{h-1}-1＜n≤2^h - 1 \ or \ 2^{h-1} ≤ n ＜ 2^h\\
    h - 1＜ log(n + 1) ≤ h \ or \ h - 1 ≤ logn ＜ h
    $$
    $h$为整数，$h = \lceil\log_2(n+1)\rceil$或者 $h = 1 + \lfloor logn \rfloor$

### 树的存储结构

1. 双亲表示法

    采用顺序存储结构，每个节点增设伪指针，值为双亲的存储下标

    ![image-20240606211751385](./.assets/image-20240606211751385.png)

2. 孩子表示法

    每个节点的孩子表示为一个线性表（以单链表为存储结构），头指针组成线性表（以顺序表为存储结构）

    ![image-20240606212006284](./.assets/image-20240606212006284.png)

3. 孩子兄弟表示法（二叉树表示法）

    以二叉链表作为树的存储结构。每个节点包括：节点值、指向节点第一个孩子的指针、指向孩子下一个兄弟的指针，**孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法**，简记为**左儿子，右兄弟**

    ![image-20240606213300223](./.assets/image-20240606213300223.png)

    ![孩子兄弟表示法示意图](./.assets/14133641I-2.gif)

### 二叉树的存储结构

1. 顺序存储结构

    数组下标为二叉树节点的编号 $i,2i,2i+1$，**建议数组下标从1开始**

2. 链式存储结构

    数据域、指针域

    ![image-20240606185405840](./.assets/image-20240606185405840.png)

### 二叉树的遍历

1. dfs遍历

    二叉树的先序中序后序，实际上就是看**先根、中根、后根**

    ```C++
    void dfs(int u){
    	print(u);//先根
    	dfs(2*u);
    	print(u);//中根
    	dfs(2*u+1);
    	print(u);//后根
    }
    ```

    

2. 层次遍历bfs

    1. 根节点入队
    2. 取出队头
    3. 扩展队头入队

    ![image-20240606185912980](./.assets/image-20240606185912980.png)

3. **由遍历序列构造二叉树**

    中序遍历+else可以得到唯一的二叉树

    **中序+先序：** 中序（BC**A**EDGHFI） 先序（**A**BCDEFGHI）先序是走根，中序把根分为了左右，左侧为左子树，右侧为右子树，然后递归分析下去

    **中序+后序： **中序（BC**A**EDGHFI） 后序（CBEHGIFD**A**）后序最后一个节点是根

    **中序+层次：** 层序遍历中，第一个节点一定是根节点，将中序序列分割成了，左子树的中序序列和右子树的中序序列。若存在左子树，则层序序列的第二个节点一定是左子树的根，可以进一步划分左子树



### 树和森林的遍历

1. 树的遍历

    1. 先根遍历
    2. 后根遍历
    3. 层次遍历

2. 森林的遍历

    1. 先序遍历森林

        访问第一棵树的根节点；先序遍历**第一棵树中根节点的子树森林**；再访问森林中的其他树组成的森林

        先序遍历森林=对森林组成的二叉树的先序遍历=**对各个树先序遍历**

        ![image-20240606221658467](./.assets/image-20240606221658467.png)

    2. 中序遍历森林

        中序遍历**第一棵树中根节点的子树森林**；访问第一棵树的根节点；中序遍历其他的树组成的森林

        中序遍历森林===对森林组成的二叉树的中序遍历=**对各个树后序遍历**

        ![image-20240606221719738](./.assets/image-20240606221719738.png)

==最靠谱的方法==

==把森林转为二叉树，左孩子、右兄弟，先序遍历or中序遍历==

### 线索二叉树（没学）

1. 定义：以一定的规则将二叉树的节点排成一个线性序列，从而得到几种遍历序列，使得该序列中的每个节点都有一个直接前驱和直接后继（首位节点除外） **理解就是把树变成线性表**

### 树、二叉树、森林的转换

1. 树转为二叉树

    **左儿子，右兄弟**

    ![image-20240606213748103](./.assets/image-20240606213748103.png)

2. 森林转换为二叉树

    1. 先将每棵树转为二叉树
    2. 因为每棵**转换后二叉树的右儿子必空**，因此用另一棵二叉树作为右儿子

3. 二叉树转为森林

    1. 每次都将二叉树的根和左子树组在一起和右子树分开，直到右子树不能再分
    2. 再把每棵二叉树转为树，就得到了原始的森林

    ![image-20240606215617976](./.assets/image-20240606215617976.png)

    

    

    

### 树和二叉树的应用



## 图

```mermaid
graph LR
	图-->图的定义
	图-->图的存储
	图-->图的遍历
	图-->图的应用
	
	图的存储-->邻接矩阵
	图的存储-->邻接表
	
	图的遍历-->DFS
	图的遍历-->BFS
	
	a1["最小生成树：Kruskal Prim"]
	a2["最短路径：Dijkstral Floyd"]
	a3["拓扑排序：AOV网"]
	a4["关键路径：AOE网"]
	图的应用-->a1
	图的应用-->a2
	图的应用-->a3
	图的应用-->a4
```



## 查找

```mermaid
graph LR
	a1["基本概念：静态查找、动态查找"]
	a2["散列结构-散列表"]
	a3["效率指标-平均查找长度"]
	查找-->a1
	查找-->线性结构
	线性结构-->顺序查找
	线性结构-->折半查找
	线性结构-->分块查找
	查找-->树形结构
	树形结构-->二叉排序树
	树形结构-->二叉平衡树
	树形结构-->B树
	树形结构-->B+树
	查找-->a2
	a2-->性能分析
	查找-->a3
	a3-->查找成功
	a3-->查找失败
```



## 排序

```mermaid
graph LR
	排序-->基本概念
	基本概念-->稳定性
	基本概念-->a1["衡量标准：时空复杂度"]
	排序-->内部排序
	内部排序-->插入排序
	插入排序-->直接插入排序
	插入排序-->折半插入排序
	插入排序-->希尔排序
	交换排序-->冒泡排序
	交换排序-->快速排序
	内部排序-->交换排序
	内部排序-->选择排序
	选择排序-->简单选择排序
	选择排序-->堆排序
	内部排序-->归并排序
	内部排序-->基数排序
	排序-->外部排序
	外部排序-->多路归并排序
```

